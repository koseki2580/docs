// @ts-check
// Note: type annotations allow type checking and IDEs autocompletion

const lightCodeTheme = require("prism-react-renderer/themes/github");
const darkCodeTheme = require("prism-react-renderer/themes/dracula");
const fs = require("fs");
const crypto = require("crypto");

let contents = [];
let sidebar_js = {};
let navbar_items = [];
getFiles();
// console.log(navbar_items);
// console.log(contents);

WriteFile(
  "./src/components/HomepageFeatures/content.js",
  WriteContents(contents, "content")
);
WriteFile("./sidebars.js", WriteContents(sidebar_js, "sidebar"));

/** @type {import('@docusaurus/types').Config} */
const config = {
  title: "備忘録",
  url: "https://koseki2580.github.io/study-docs",
  baseUrl: "/study-docs/",
  onBrokenLinks: "throw",
  onBrokenMarkdownLinks: "warn",
  // favicon: 'img/favicon.ico',

  // GitHub pages deployment config.
  // If you aren't using GitHub pages, you don't need these.
  organizationName: "koseki2580", // Usually your GitHub org/user name.
  projectName: "study-docs", // Usually your repo name.

  // Even if you don't use internalization, you can use this field to set useful
  // metadata like html lang. For example, if your site is Chinese, you may want
  // to replace "en" with "zh-Hans".
  i18n: {
    defaultLocale: "ja",
    locales: ["ja"],
  },

  presets: [
    [
      "classic",
      /** @type {import('@docusaurus/preset-classic').Options} */
      ({
        docs: {
          showLastUpdateTime: true,
          sidebarPath: require.resolve("./sidebars.js"),
          // Please change this to your repo.
          // Remove this to remove the "edit this page" links.
          editUrl: "https://github.com/koseki2580/study-docs/edit/main/",
        },
        theme: {
          customCss: require.resolve("./src/css/custom.css"),
        },
      }),
    ],
  ],

  themeConfig:
    /** @type {import('@docusaurus/preset-classic').ThemeConfig} */
    ({
      navbar: {
        title: "勉強メモ",
        // items: [
        //   {
        //     type: 'doc',
        //     docId: 'Algorithm/home',
        //     to : "docs/Algorithm/home",
        //     position: 'left',
        //     label: 'ドキュメント',
        //   },
        //   {
        //     type: 'dropdown',
        //     label: 'Tutorials',
        //     items: [
        //       {type: 'doc', to:"/docsAlgorithm/home", label:"aaaa",docId: 'Algorithm/home'},
        //       {type: 'doc', to:"/docsAlgorithm/home", label:"bbb", docId: 'Algorithm/home'},
        //     ],
        //   },
        //   {
        //     type: 'search',
        //     position: 'right',
        //   },
        // ],
        items: navbar_items,
      },
      footer: {},
      prism: {
        additionalLanguages: ["csharp"],
        theme: lightCodeTheme,
        darkTheme: darkCodeTheme,
      },
    }),
  plugins: [
    [
      require.resolve("@cmfcmf/docusaurus-search-local"),
      {
        // Options here
        language: "ja",
        indexDocSidebarParentCategories: 1,
      },
    ],
  ],
};

module.exports = config;

/**
 * docsの親要素・子要素をjson形式で取り出し
 */

function getFiles() {
  // docsを見て、インデックスページなどを作成するのでベースのURLを作成する
  let baseUrl = "./docs/";
  let parentdatas = fs.readdirSync(baseUrl);

  // 正規表現でマッチするファイルのみ検索する
  const pattern = /(^\d{2}-[a-zA-Z]+)|(_category_.json)/g;

  // docs直下の親要素を探索する
  for (let i = 0; i < parentdatas.length; ++i) {
    // マッチしないファイルは検索対象外
    if (parentdatas[i].match(pattern) === null) continue;

    // 親データの形は以下のなので定義する
    let parentdata = {
      headtitle: "",
      contents: [],
    };
    // 親要素の名前を取り出す
    let parentName = RemovePrefix(parentdatas[i]);

    // サイドバーのコンフィグを設定する
    sidebar_js[parentName + "Sidebar"] = [
      { type: "autogenerated", dirName: parentdatas[i] },
    ];

    let navparent = {
      type: "dropdown",
      label: "",
      items: [],
    };

    // {type: 'doc', to:"/docsAlgorithm/home", label:"aaaa",docId: 'Algorithm/home'},
    // {type: 'doc', to:"/docsAlgorithm/home", label:"bbb", docId: 'Algorithm/home'},

    // 親要素までパス
    let parentPath = "docs/" + parentName;

    // 子要素を取得する
    let childrendatas = fs.readdirSync(baseUrl + parentdatas[i] + "/");

    // 子要素を調べる
    for (let j = 0; j < childrendatas.length; ++j) {
      // マッチしないファイルは検索対象外
      if (childrendatas[j].match(pattern) === null) continue;

      // 親要素のタイトルをとる
      if (childrendatas[j] === "_category_.json") {
        // JSONオブジェクトを取得
        const jsonObject = JSON.parse(
          fs.readFileSync(
            baseUrl + parentdatas[i] + "/" + childrendatas[j],
            "utf8"
          )
        );
        parentdata.headtitle = jsonObject.label;
        navparent.label = jsonObject.label;
        continue;
      }

      // 子要素の名前を取り出し
      let childrenName = childrendatas[j].split(".");
      // mdファイルの場合
      if (childrenName.length >= 2) {
        // ファイル読み込み
        let title = fs.readFileSync(
          baseUrl + parentdatas[i] + "/" + childrendatas[j],
          "utf8"
        );
        let draft = title.split("---")[1].split("\n")[3].split(" ")[1];
        if (draft === "true") continue;
        // mdファイルからタイトル要素取り出し
        title = title.split("---")[1].split("\n")[1].split(" ")[1];

        let childName = RemovePrefix(childrenName[0]);
        // インデックスページに表示するコンテンツ
        let childrendata = {
          title: title,
          href: parentPath + "/" + childName,
        };
        parentdata.contents.push(childrendata);

        // navbarに子要素を入れる
        let navbaritem = {
          type: "doc",
          to: `/docs/${parentName}/${childName}`,
          label: title,
          docId: `${parentName}/${childName}`,
        };
        navparent.items.push(navbaritem);
        continue;
      }
      // フォルダーの場合（孫要素が存在する場合）
      let finaldatas = fs.readdirSync(
        baseUrl + parentdatas[i] + "/" + childrendatas[j] + "/"
      );
      for (let k = 0; k < finaldatas.length; ++k) {
        // マッチしないものは取り除く
        if (finaldatas[k].match(pattern) === null) continue;

        // ファイル名を取得する（フォルダ名はjsonに記載している）
        if (finaldatas[k] === "_category_.json") {
          // jsonファイルを読み込み
          const jsonObject = JSON.parse(
            fs.readFileSync(
              baseUrl +
                parentdatas[i] +
                "/" +
                childrendatas[j] +
                "/_category_.json",
              "utf8"
            )
          );

          let childName = RemovePrefix(childrendatas[j]);
          // コンテンツ
          let childrendata = {
            title: jsonObject.label,
            href: parentPath + "/" + childName + "/",
          };
          parentdata.contents.push(childrendata);

          // navbarに子要素を入れる
          let navbaritem = {
            type: "doc",
            to: `/docs/${parentName}/${childName}`,
            label: jsonObject.label,
            docId: `${parentName}/${childName}/README`,
          };
          navparent.items.push(navbaritem);
          break;
        }
      }
    }
    navbar_items.push(navparent);
    contents.push(parentdata);
  }
  navbar_items.push({
    type: "search",
    position: "right",
  });
}

/**
 *
 * ファイル名のプレフィックスを取り除く(00-部分)
 * @param {string} filename ファイル名
 *
 * @returns filename
 */
function RemovePrefix(filename) {
  let temp = filename.split("-");
  let res = "";
  for (let i = 1; i < temp.length; ++i) {
    res += temp[i];
    if (i !== temp.length - 1) res += "-";
  }
  return res;
}

function WriteContents(contents, variable) {
  let str = `const ${variable} = ${JSON.stringify(
    contents
  )}\nmodule.exports = ${variable};`;
  return str;
}

/**
 * ファイルを書き出す際に前のファイルと変化しているか確認してから書き出す
 * @param {string} path 保存先のパス
 * @param {string} data 保存するデータ
 * @returns 戻り値なし
 */
// ファイルを常に書き込むとホットリロードの際に無限ループに入るためファイルの内容が変更しているか確認し、変更されていればファイルを書き出す
function WriteFile(path, data) {
  let oddData = fs.readFileSync(path).toString();
  if (
    crypto.createHash("md5").update(oddData).digest("hex") ===
    crypto.createHash("md5").update(data).digest("hex")
  )
    return;
  fs.writeFileSync(path, data);
}
