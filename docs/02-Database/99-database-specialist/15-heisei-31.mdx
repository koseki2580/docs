---
title: 平成31年
sidebar_label: 平成31年
draft: false
toc_max_heading_level: 5
tags: [データベース, 資格, データベーススペシャリスト, 午後1, 午後2]
---

```mdx-code-block
import UnderLine from "@site/src/components/Custom/UnderLine"
import FontColor from "@site/src/components/Custom/FontColor"

```

:::caution 注意事項
一個人の解答からここが根拠だろうという部分を取り出してまとめたものになります。
:::
以下の写真は全て実際の問題よりスクリーンショットで取得したものを表示させています。
また、「」内の文字は問題からそのまま引用しています。

## 午後 1

出典 : 平成 31 年度 春期 データベーススペシャリスト試験　午後 1

[問題](https://www.jitec.ipa.go.jp/1_04hanni_sukiru/mondai_kaitou_2019h31_1/2019h31h_db_pm1_qs.pdf)

[解答](https://www.jitec.ipa.go.jp/1_04hanni_sukiru/mondai_kaitou_2019h31_1/2019h31h_db_pm1_ans.pdf)

問題と解答は上記からダウンロードすることができます。

解答作成中

## 午後 2

出典 : 平成 31 年度 春期 データベーススペシャリスト試験　午後 2

[問題](https://www.jitec.ipa.go.jp/1_04hanni_sukiru/mondai_kaitou_2019h31_1/2019h31h_db_pm2_qs.pdf)

[解答](https://www.jitec.ipa.go.jp/1_04hanni_sukiru/mondai_kaitou_2019h31_1/2019h31h_db_pm2_ans.pdf)

問題と解答は上記からダウンロードすることができます。

### 大問 1

#### 設問 1

##### (1)

- 表 2 にある処理 5,6 で使用するテーブル名を答える問題

![午後2 問1 表4](/img/png/Database/database-specialist/H31/2-1-chart-4.png "午後2 問1 表4")

![午後2 問1 表2](/img/png/Database/database-specialist/H31/2-1-chart-2.png "午後2 問1 表2")

表 4 で使用されているテーブルについては図 1 に乗っている。

![午後2 問1 図1](/img/png/Database/database-specialist/H31/2-1-figure-1.png "午後2 問1 図1")

- 処理 5

  処理 5 は「店番、端末種別コードごとに明細件数を集計して、店番、店名、端末種別コード、端末種別名、合計明細件数を出力する。」とあるので
  出力される`店番`, `店名`, `端末種別コード`, `端末種別名`, `合計明細件数`が必要であることが分かる。

  この中で`店番`, `合計明細件数`はログ基本テーブルから導出することができ、残りの`店名`, `端末種別コード`, `端末種別名`をどのテーブルから持ってくるかを検討する。

  端末種別名は図 1 を見ると端末種別テーブルにしかないので、こちらを使用することが分かる。しかし、端末種別名は`端末種別コード`を主キーとしており、ログ基本テーブルには端末種別コードは存在しない。
  図 1 を見ると窓口端末テーブルには端末種別コードが外部キーとして設定されており、主キーがログ基本テーブルの外部キーとして設定されている`店番`, `機番`となっている。

  つまり、`ログ基本テーブル` $\rightarrow$ `窓口端末テーブル` $\rightarrow$ `端末種別テーブル`の順に探索することで`端末種別コード`, `端末種別名`を取得できる。

  店名は図 1 を見ると支店テーブルに存在し、主キーが店番となっている。ログ基本テーブルの外部キーに店番が存在するので

  `ログ基本テーブル` $\rightarrow$ `支店テーブル`で探索でき、`店名`を取得できる。

  処理 5 で使用するテーブルは`支店テーブル`, `端末種別テーブル`, `窓口端末テーブル`, `ログ基本テーブル`となる。

- 処理 6

  処理 6 は「店名、取引種別名ごとに、明細件数を集計して、画面番号、タイトル、店名、取引種別名、合計明細件数を出力する。」とあるので、
  出力される`画面番号`, `タイトル`, `店名`, `取引種別名`, `合計明細件数`が必要であることが分かる。

  この中で`画面番号`, `合計明細件数`はログ基本テーブルから導出することができ、残りの`タイトル`, `店名`, `取引種別名`をどのテーブルから持ってくるかを検討する。

  店名は処理 5 と同様に`支店テーブル`を用いることで導出できる。

  タイトルは図 1 を見ると画面テーブルに存在し、主キーが画面番号となっている。ログ基本テーブルの外部キーに画面番号が存在するので

  `ログ基本テーブル` $\rightarrow$ `画面テーブル`で探索でき、`タイトル`を取得できる。

  取引種別名は図 1 を見ると取引種別テーブルにしかないので、こちらを使用することが分かる。しかし、取引種別名は`取引種別コード`を主キーとしており、ログ基本テーブルには取引種別コードは存在しない。
  図 1 を見ると取引テーブルには取引種別コードが外部キーとして設定されており、主キーがログ基本テーブルの外部キーとして設定されている`取引番号`となっている。

  つまり、`ログ基本テーブル` $\rightarrow$ `取引テーブル` $\rightarrow$ `取引種別テーブル`の順に探索することで`取引種別コード`, `取引種別名`を取得できる。

  処理 6 で使用するテーブルは`支店テーブル`, `取引種別テーブル`, `取引テーブル`, `画面テーブル`, `ログ基本テーブル`となる。

##### (2)

- 索引を定義する問題

![午後2 問1 表5](/img/png/Database/database-specialist/H31/2-1-chart-5.png "午後2 問1 表5")

テーブルの主キーには索引が定義されている(図 1 下部の注記に記載)。索引については、ページ 10 $>$ 5. テーブルの物理分割　に記述されている。

表は 2 つ空欄が存在するので、2 つテーブル名と列名を定義する必要がある。

表 2 の処理内容を見てみると、

- 処理 4

  処理 4 に「 $\sim$ 年月、行員番号、取引種別コードごとに伝票金額を集計して $\sim$ 」とあり、取引種別コードが

  取引種別コードを導出するには(1)でも記述したように取引テーブルの外部キーを使用しないと取得することができない。
  外部キーは索引の対象外なので取引種別コードはバラバラに物理的に格納されてしまうので、探索に時間がかかってしまう。
  そのため、取引テーブルの取引種別コードに索引を定義することでこの時間の短縮することが可能となる。

- 処理 5

  処理 5 に「 $\sim$ 店番、端末種別コードごとに明細件数を集計して　$\sim$ 」とあり、端末種別コードで結果をまとめているが分かる。

  端末種別コードを導出するには(1)でも記述したように窓口端末テーブルの外部キーを使用しないと取得することができない。
  外部キーは索引の対象外なので端末種別コードはバラバラに物理的に格納されてしまうので、探索に時間がかかってしまう。
  そのため、窓口端末テーブルの端末種別コードに索引を定義することでこの時間の短縮することが可能となる。

まとめると

| テーブル名 | 索引を定義する列名 |
| :--------: | :----------------: |
|  窓口端末  |   端末種別コード   |
|    取引    |   取引種別コード   |

##### (3)

- SQL を答える問題

![午後2 問1 図2](/img/png/Database/database-specialist/H31/2-1-figure-2.png "午後2 問1 図2")

表 2 の処理 1 をまとめると

| 番号 | 所属する支店 | 当該利用者 |            説明            |
| :--: | :----------: | :--------: | :------------------------: |
|  1   |   $\circ$    |  $\circ$   | 所属する支店かつ本人のログ |
|  2   |   $\circ$    |            |    　所属する支店のログ    |
|  3   |              |            |           全ログ           |

となっている。
図 2 の最後をみると

```sql
...
WHERE A.年月 = :hv2
  AND A.店番 = B.店番
  AND A.行員番号 = C.行員番号
  AND A.取引番号 = D.取引番号
  AND (E.検索店番 c OR E.検索店番 = A.店番)
  AND (E.検索行員番号 c OR E.検索行員番号 = A.行員番号)
```

となっており、where 句を用いて対象を絞っている。上記の最後の部分をみると`E.検索店番`と`E.検索行員番号`が`c`の時か番号が一致した場合に true となることがわかる。

これを踏まえて、a について見てみると

```sql
CASE WHEN 権限レベル a THEN 所属店番 ELSE NULL END AS 検索店番
```

となっており、a の条件を満たすとき所属番号を持ち、満たさないときは NULL となる。

店番で検索する条件は上の表を見ると権限レベルが 1,2 の時に店番で検索する必要があるので、a は

`IN ('1', '2')`となる。

b も同じように考えると検索行員番号を必要とするのは権限レベルが 1 の時であるので、

`= '1'`となる。

権限レベル 3 の時は`E.検索店番`と`E.検索行員番号`が NULL となっており、NULL の時にも true となる条件が必要になる。

そのため、c は`IS NULL`となる。

d は、図 3-5 で共通で使われる SQL 文を考える必要がある。

![午後2 問1 図3](/img/png/Database/database-specialist/H31/2-1-figure-3.png "午後2 問1 図3")

処理 2 を見ると「 $\sim$ 平均経過時間の降順で出力する。 $\sim$ 」とあるので、

`ORDER BY 平均経過時間 DESC`となることが分かる。

##### (4)

- 空欄に当てはまる問題

![午後2 問1 図5](/img/png/Database/database-specialist/H31/2-1-figure-5.png "午後2 問1 図5")

処理 2 は後画面番号 - 前画面番号の TS 時間の平均を求める処理であり、一つ先 or 一つ前のデータ引いた絶対値の平均を求めている。
図 5 を見ると A(基準)を用いて B(一つ前)を探索していることが SQL 文を見るとわかる。

つまり、TS 順に並んだ番号が存在すれば、1 つ目の番号は基準の-1 となるので、TS 順に並んだ番号が必要であることが分かる。

処理 2 自体が店番と機番ごとに集計しているので、`店番, 機番, TS順の順に連続する整数`となる。

#### 設問 2

##### (1)

- SQL 文を答える問題

![午後2 問1 表10](/img/png/Database/database-specialist/H31/2-1-chart-10.png "午後2 問1 表10")

![午後2 問1 表6-9](/img/png/Database/database-specialist/H31/2-1-chart-6-9.png "午後2 問1 表6-9")

- e,f について考える。

案 1 は自身の親となるログ ID を外部キーとして持つ方法である。

問い合わせ[B]は「ログ ID='105'及びその上位の全ての ID を抽出する」である。
表 10 の案 1 の問い合わせ B をみるとログ ID が`105`であるという条件での絞り込みが行われていない。

そのため、e は`ログID = '105'`となる。

表 10 の案 1 の問い合わせ B は`WITH RECURSIVE`を使用している。`RECURSIVE`についてはページ 10 $>$ 3. 再帰的な問合せの構文のサポートに記述されている。

f の SQL 文は以下であり、

```sql
SELECT A.ログID, A.親ログID
FROM ログ関連 A, TEMP B
WHERE A.ログID = f
```

TEMP で自分自身を参照している。問い合わせ B ではログ ID が 105 と上位(105 の親)を全て抽出するので、TEMP 属性の親属性を使えば親要素を抽出できるので、
f は`B.親ログID`となる。

`UNION ALL`で検索結果を結合しているが、e 側の結果は 105 の時(一番初め)だけ結果があり、f 側の結果はそれ以外(105 よりも上位の結果のみ)を抽出するようになっている。

- g,h について考える

案 3 は木構造の行きかけ順(左端番号)と帰りがけ順(右端番号)に番号を付与していく方法である。

この番号付けを行うと左端番号と右端番号の間に左端番号と右端番号(左端番号 $<$ x.左端番号 , x.右端番号 $<$ 右端番号)が存在する時は、その番号(x)を持つ要素は子要素であるという性質がある。

そのため、ログ ID が 105 の親要素を全て抽出するには基準(ログ ID 105)となる番号の左端番号より小さく、右端番号が大きい番号を持つ要素は 105 よりも上位に位置する要素であると言えるので、

g,h はそれぞれ`A.左端番号 >= B.左端番号`と`A.右端番号 <= B.右端番号`となる。

`=`がついているのはログ ID が 105 も抽出するからである。

##### (2)
